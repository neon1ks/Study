# Описание программы

1. `fibonacci-get.cpp`

    Получение небольшого числа Фибоначчи: [Шаг 6 · Числа Фибоначчи · Stepik](https://stepik.org/lesson/13228/step/6?unit=3414)

    Дано целое число $1 \le n \le 40$, необходимо вычислить `n`-е число Фибоначчи (напомним, что $F_0 = 0$, $F_1=1$ и $F_n=F_{n-1}+F_{n-2}$​ при $n \ge 2$).

2. `fibonacci-get-last-digit.cpp`

    Получение последней цифры большого числа Фибоначчи: [Шаг 7 · Числа Фибоначчи · Stepik](https://stepik.org/lesson/13228/step/7?unit=3414)

    Дано число $1 \le n \le 10^7$, необходимо найти последнюю цифру `n`-го числа Фибоначчи.

    Как мы помним, числа Фибоначчи растут очень быстро, поэтому при их вычислении нужно быть аккуратным с переполнением. В данной задаче, впрочем, этой проблемы можно избежать, поскольку нас интересует только последняя цифра числа Фибоначчи: если $0 \le a,b \le 9$ — последние цифры чисел $F_i$ и $F_{i+1}$​ соответственно, то $(a+b) \bmod{10}$ — последняя цифра числа $F_{i+2}$​.

3. `fibonacci-get-remainder.cpp`

    Получение огромного числа Фибоначчи по модулю: [Шаг 8 · Числа Фибоначчи · Stepik](https://stepik.org/lesson/13228/step/8?unit=3414)

    Даны целые числа $1 \le n \le 10^{18}$ и $2 \le m \le 10^5$, необходимо найти остаток от деления `n`-го числа Фибоначчи на `m`.

4. `greatest-common-divisor.cpp`

    Получение наибольшего общего делителя [Шаг 5 · Наибольший общий делитель · Stepik](https://stepik.org/lesson/13229/step/5?unit=3415)

    По данным двум числам $1 \le a, b \le 2 \cdot 10^9$ найдите их наибольший общий делитель.

5. `get_covering_set.cpp`

    Покрыть отрезки точками: [Шаг 9 · Введение · Stepik](https://stepik.org/lesson/13238/step/9?unit=3424)

    По данным $n$ отрезкам необходимо найти множество точек минимального размера, для которого каждый из отрезков содержит хотя бы одну из точек.

    В первой строке дано число $1 \le n \le 100$ отрезков. Каждая из последующих $n$ строк содержит по два числа $0 \le l \le r \le 10^9$, задающих начало и конец отрезка. Выведите оптимальное число $m$ точек и сами $m$ точек. Если таких множеств точек несколько, выведите любое из них.

6. `get_max_knapsack_value.cpp`

    непрерывный рюкзак: [Шаг 10 · Введение · Stepik](https://stepik.org/lesson/13238/step/10?unit=3424)

    Первая строка содержит количество предметов $1 \le n \le 10^3$ и вместимость рюкзака $0 \le W \le 2 \cdot 10^6$. Каждая из следующих $n$ строк задаёт стоимость $0 \le c_i \le 2\cdot 10^6$ и объём $0 \lt w_i \le 2\cdot 10^6$ предмета ($n$, $W$, $c_i$​, $w_i$​ — целые числа). Выведите максимальную стоимость частей предметов (от каждого предмета можно отделить любую часть, стоимость и объём при этом пропорционально уменьшатся), помещающихся в данный рюкзак, с точностью не менее трёх знаков после запятой.

7. `get_various_terms.cpp`

    различные слагаемые: [Шаг 11 · Введение · Stepik](https://stepik.org/lesson/13238/step/11?unit=3424)

    По данному числу $1 \le n \le 10^9$ найдите максимальное число $k$, для которого $n$ можно представить как сумму $k$ различных натуральных слагаемых. Выведите в первой строке число $k$, во второй — $k$ слагаемых.

8. `huffman_encoding.cpp`

    кодирование Хаффмана: [Шаг 5 · Коды Хаффмана · Stepik](https://stepik.org/lesson/13239/step/5?unit=3425)

    По данной непустой строке $s$ длины не более $10^4$, состоящей из строчных букв латинского алфавита, постройте оптимальный беспрефиксный код. В первой строке выведите количество различных букв $k$, встречающихся в строке, и размер получившейся закодированной строки. В следующих $k$ строках запишите коды букв в формате `letter: code`. В последней строке выведите закодированную строку.

9. `dhuffman_decode.cpp`

    декодирование Хаффмана: [Шаг 6 · Коды Хаффмана · Stepik](https://stepik.org/lesson/13239/step/6?unit=3425)

    Восстановите строку по её коду и беспрефиксному коду символов.

    В первой строке входного файла заданы два целых числа $k$ и $l$ через пробел — количество различных букв, встречающихся в строке, и размер получившейся закодированной строки, соответственно. В следующих $k$ строках записаны коды букв в формате `letter: code`. Ни один код не является префиксом другого. Буквы могут быть перечислены в любом порядке. В качестве букв могут встречаться лишь строчные буквы латинского алфавита; каждая из этих букв встречается в строке хотя бы один раз. Наконец, в последней строке записана закодированная строка. Исходная строка и коды всех букв непусты. Заданный код таков, что закодированная строка имеет минимальный возможный размер.

    В первой строке выходного файла выведите строку $s$. Она должна состоять из строчных букв латинского алфавита. Гарантируется, что длина правильного ответа не превосходит $10^4$ символов.

10. `max_priority_queue.cpp`

    очередь с приоритетами: [Шаг 8 · Очереди с приоритетами · Stepik](https://stepik.org/lesson/13240/step/8?unit=3426)

    Первая строка входа содержит число операций $1 \le n \le 10^5$. Каждая из последующих $n$ строк задают операцию одного из следующих двух типов:

    * `Insert x`, где $0 \le x \le 10^9$ — целое число;
    * `ExtractMax`.

    Первая операция добавляет число $x$ в очередь с приоритетами, вторая — извлекает максимальное число и выводит его.

11. `binary_search_algorithm` — бинарный поиск

12. `inversion_count`

    число инверсий: [Шаг 5 · Сортировка слиянием · Stepik](https://stepik.org/lesson/13248/step/5?unit=3433)

    Первая строка содержит число $1 \le n \le 10^5$, вторая — массив $A[1\ldots n]$, содержащий натуральные числа, не превосходящие $10^9$. Необходимо посчитать число пар индексов $1 \le i \lt j \le n$, для которых $A[i] \gt A[j]$. (Такая пара элементов называется инверсией массива. Количество инверсий в массиве является в некотором смысле его мерой неупорядоченности: например, в упорядоченном по неубыванию массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию, инверсию образуют каждые два элемента.)

13. `points_and_lines`

    точки и отрезки: [Шаг 6 · Быстрая сортировка · Stepik](https://stepik.org/lesson/13249/step/6?unit=3434)

    В первой строке задано два целых числа $1 \le n \le 50000$ и $1 \le m \le 50000$ — количество отрезков и точек на прямой, соответственно. Следующие $n$ строк содержат по два целых числа $a_i$​ и $b_i$​ ($a_i \le b_i$​) — координаты концов отрезков. Последняя строка содержит $m$ целых чисел — координаты точек. Все координаты не превышают $10^8$ по модулю. Точка считается принадлежащей отрезку, если она находится внутри него или на границе. Для каждой точки в порядке появления во вводе выведите, скольким отрезкам она принадлежит.

14. `quicksort` — алгоритм быстрой сортировки
